\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}


\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{table}[H]
\caption{Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
01/13/2024 & 0.1 & Sections 2--5 \\
01/17/2024 & 0.2 & Section 6\\
03/09/2025 & 0.3 & Updates to Item, Expense, Income, Budget, Categorization modules\\
\ldots & \ldots & \ldots \\
\bottomrule
\end{tabularx}
\end{table}

~\newpage

\section{Symbols, Abbreviations and Acronyms}
Refer to Section 1.3 of the
\href{https://github.com/PlutosCapstone/Plutos/blob/main/docs/SRS/SRS.pdf}{SRS
Documentation} for general abbreviations and acronyms. Additional abbreviations
and acronyms are listed below.


\renewcommand{\arraystretch}{1.2}
\begin{table}[H]
\caption{List of Abbreviations and Acronyms}
\centering
\begin{tabularx}{\textwidth}{l X} 
	\toprule		
	\textbf{symbol} & \textbf{description}\\
	\midrule 
	M & Module \\
	MG & Module Guide \\
  MIS & Module Interface Specification\\
	R & Requirement\\
	SRS & Software Requirements Specification\\
	\bottomrule
\end{tabularx}
\end{table}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications (MIS) for the
Plutos project.

Complementary documents include the
\href{https://github.com/PlutosCapstone/Plutos/blob/main/docs/SRS/SRS.pdf}{System
Requirement Specifications (SRS)} and
\href{https://github.com/PlutosCapstone/Plutos/blob/main/docs/Design/SoftArchitecture/MG.pdf}{Module
Guide (MG)}. The full documentation and implementation for the project can be
found in the \href{https://github.com/PlutosCapstone/Plutos/tree/main}{Plutos
repository}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\renewcommand{\arraystretch}{1.2}
\begin{table}[H]
\caption{Data Types}
\centering
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
string & string & a sequence of characters\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
float/real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
boolean & Boolean & a binary value, either true or false\\
\bottomrule
\end{tabular} 
\end{table}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

An overview of the module decomposition can be found in Section 5 of the
\href{https://github.com/PlutosCapstone/Plutos/blob/main/docs/Design/SoftArchitecture/MG.pdf}{Module
Guide document}.


~\newpage

\section{MIS of OCR Processing Module}\label{OCR_Processing_Module}

\subsection{Module}

OCR Processing Module

\subsection{Uses}

\begin{itemize}
  \item Image processing libraries (OpenCV, PIL)
  \item Text parsing utilities (Pytesseract OCR)
  \item Input Format Module (\nameref{input_format_module})
  \item Categorization Module (\nameref{categorization_module})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}


\begin{center}
  \begin{table}[H]
    \caption{OCR Processing Module Access Programs}
  \renewcommand{\arraystretch}{1.5} % Adjust row height
  \setlength{\tabcolsep}{8pt} % Adjust column spacing
  \begin{tabular}{|p{6cm}|p{3cm}|p{2cm}|p{5cm}|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  processImage & 
  \begin{tabular}[c]{@{}l@{}}Image file \\ (binary)\end{tabular} & 
  \begin{tabular}[c]{@{}l@{}}Text data \\ (structured)\end{tabular} & 
  FileError \\
  \hline
  validateImage & 
  \begin{tabular}[c]{@{}l@{}}Image file \\ (binary)\end{tabular} & 
  Boolean & 
  FormatError \\
  \hline
  \end{tabular}
  \end{table}
  \end{center}


\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

This module interacts with the file system to read image files and uses external OCR libraries or APIs to extract text data.

\subsubsection{Assumptions}

The input image is in a supported format (e.g., JPEG, PNG). The OCR library or API is available and correctly configured.

\subsubsection{Access Routine Semantics}

\noindent \textbf{processImage}():
\begin{itemize}
\item transition: Parses the image and converts it into structured text data.
\item output: Structured text data extracted from the image.
\item exception: Throws a FileError if the image cannot be read or an unsupported format is provided.
\end{itemize}

\noindent \textbf{validateImage}():
\begin{itemize}
\item transition: Validates the input image format and dimensions.
\item output: Returns true if the image is valid; false otherwise.
\item exception: Throws a FormatError if the image format is invalid.
\end{itemize}

\subsubsection{Local Functions}

localImageProcessing():
\begin{itemize}
\item This function applies pre-processing steps to the image, such as resizing, noise reduction, or thresholding, before OCR is applied.
\end{itemize}

localTextExtraction():
\begin{itemize}
\item This function uses an OCR library to extract raw text from the pre-processed image.
\end{itemize}

\newpage


%% start of Categorization module ----------

\section{MIS of Categorization Module}\label{categorization_module}

\subsection{Module}
Categorization Module

\subsection{Uses}
OCR Processing Module (\nameref{OCR_Processing_Module})\\

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{table}[H]
    \caption{Categorization Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
% \wss{accessProg} & - & - & - \\\
categorize & item: Item & category: string & InvalidInputError \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
This specification assumes that the model has been trained and is ready to
classify items based on the input data.

\subsubsection{Access Routine Semantics}

\noindent categorize(item: Item):
\begin{itemize}
\item transition: N/A 
\item output: string 
\item exception: InvalidInputError -- thrown if the input is not an Item object
\end{itemize}

\subsubsection{Local Functions}
\noindent \_\_train\_model(csv: File):
\begin{itemize}
  \item transition: N/A
  \item input: csv -- a CSV file containing labeled data (item\_name, category)
  from parsed receipt item names and manually verified categories.
  \item output: three .pkl files (model, vectorizer, encoder) for item
  categorization. These files are opened and loaded during the initialization of
  the Categorization class and are used within categorize(). It is assumed that
  this model has been trained and does not need to be modified during runtime.
  \item model: The model will build off of Cohere's categorization classify
  feature, using a dataset of receipt items and categories to fine-tune the
  model. The expected accuracy of the model is 80\%.
\end{itemize}

\newpage

% end of Categorization Module


% start of budget calculation module
\section{MIS of Budget Calculation Module}\label{budget_calculation_module}

\subsection{Module}

Budget Calculation Module

\subsection{Uses}
Categorization Module (\nameref{categorization_module})\\
Expense Module (\nameref{expense_module})\\
Income Module (\nameref{income_module})\\
Budget Module (\nameref{budget_module})\\

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{table}[H]
  \caption{Budget Calculation Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
calculate\_budget & expenses: List[Expense] & suggested\_budget: List[Dict[string, float]]
& InvalidInputError \\
& income: List[Income] & &  \\
& budget: List[Budget] & &  \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}

\noindent calculate\_budget(history: List[Transaction], savings\_goals: List[Dict[string, float]]):
\begin{itemize}
\item transition: N/A
\item output: Dict[string, float] -- a list of remaining budgets for each
category and unallocated\\
\[
\text{Categories} := \{ \text{budget.category} \mid \text{budget} \in \text{Budget} \}
\]
\[
\text{expenses}_C := \sum_{\substack{\text{expense}_i \in \text{Expenses} \\ \text{expense}_i.\text{category} == C}} \text{expense}_i.\text{cost}
\]\\
\[
\text{budget}_C := \text{budget[C]}.\text{amount}
\]\\
\[
\text{remaining}_C := 
\begin{cases} 
\text{budget}_C - \text{expenses}_C & \text{if } C \in \text{Categories} \\
0 & \text{otherwise}
\end{cases}
\]\\
\[
\text{total\_income} := \sum_{\text{income}_i \in \text{Income}} \text{income}_i
\]\\
\[
\text{unallocated} := \text{total\_income} - \sum_{C \in \text{Categories}} \text{budget}_C - \sum_{ \text{expenses}_C | C \notin \text{Categories}} \text{expenses}_C
\]\\
\[
\text{output} := \bigcup_{C \in \text{Categories}} \left( \{\text{C} : \text{remaining}_C \} \right) \cup \{\text{unallocated}: \text{unallocated} \}
\]\\
\item exception: InvalidInputError -- thrown if the input is not valid
\end{itemize}

\subsubsection{Local Functions}
N/A

\newpage
% end of budget calculation module


% start of authentication module
\section{MIS of Authentication Module}\label{Authentication_Module}
This module manages user authentication, utilizing Firebase Authentication to handle login and registration. It also interacts with React Native components for the user interface.

\subsection{Module}

Authentication Module

\subsection{Uses}
This module uses Firebase for authentication purposes. It interacts with
Firebase Authentication to handle user login and registration, as well as React
Native components for the user interface.

\subsection{Syntax}

\subsubsection{Exported Constants}

\begin{itemize}
    \item \textbf{auth}: An instance of Firebase Authentication, initialized using the Firebase app.
    \item \textbf{db}: An instance of Firebase Firestore, initialized using the Firebase app.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{table}[H]
\caption{Authentication Module Access Programs}
  \renewcommand{\arraystretch}{1.5} % Adjust row height
  \setlength{\tabcolsep}{8pt} % Adjust column spacing
  \begin{tabular}{|p{6cm}|p{3cm}|p{2cm}|p{5cm}|}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  loginWithEmailPassword & 
  \begin{tabular}[c]{@{}l@{}}email (string), \\ password (string)\end{tabular} & 
  user object & 
  \begin{tabular}[c]{@{}l@{}}InvalidEmail, MissingPassword, \\ InvalidCredential, GeneralError\end{tabular} \\
  \hline
  createUserWithEmailAndPassword & 
  \begin{tabular}[c]{@{}l@{}}email (string), \\ password (string)\end{tabular} & 
  user object & 
  \begin{tabular}[c]{@{}l@{}}InvalidEmail, WeakPassword, \\ GeneralError\end{tabular} \\
  \hline
  \end{tabular}
\end{table}
  \end{center}

\subsection{Semantics}

\subsubsection{State Variables}

The module maintains state for username, password, and credential error messages to support user interactions and error handling.

\subsubsection{Environment Variables}

The module interacts with the Firebase Authentication API for user management and relies on Firebase configuration to communicate with the backend services.

\subsubsection{Assumptions}

It is assumed that the Firebase configuration is valid and correctly set up. Network connectivity is also assumed to be available for authentication operations.

\subsubsection{Access Routine Semantics}

\noindent \textbf{loginWithEmailPassword}(email: string, password: string):
\begin{itemize}
\item transition: if $\exists \text{ (email, password)} \text{ such that }
\text{(email, password)} \in \text{db} \Rightarrow \text{auth} :=
\text{FirebaseAuth}$
\item output: Returns a user object containing user details upon successful login.
\item exception: 
    \begin{itemize}
        \item \textbf{InvalidEmail:} The email address is not valid.
        \item \textbf{MissingPassword:} No password was provided.
        \item \textbf{InvalidCredential:} Email or password is incorrect.
        \item \textbf{GeneralError:} A generic error occurred during login.
    \end{itemize}
\end{itemize}

\noindent \textbf{createUserWithEmailAndPassword}(email: string, password: string):
\begin{itemize}
\item transition: $\text{auth} := \text{FirebaseAuth}$
\item output: Returns a user object containing user details upon successful registration.
\item exception: 
    \begin{itemize}
        \item \textbf{InvalidEmail:} The email address is not valid.
        \item \textbf{WeakPassword:} The password provided is too weak.
        \item \textbf{GeneralError:} A generic error occurred during registration.
    \end{itemize}
\end{itemize}

\subsubsection{Local Functions}

\textbf{validateCredentials}(username: string, password: string):
\begin{itemize}
\item Checks the validity of the entered username and password before attempting login or registration.
\end{itemize}

\noindent\textbf{handleErrors}(error: FirebaseError):
\begin{itemize}
\item Maps Firebase error codes to user-friendly error messages displayed on the UI.
\end{itemize}

\newpage
% end of authentication module


% start of upload interface module
\section{MIS of Upload Interface Module}\label{upload_interface_module}

\subsection{Module}

Upload Interface Module

\subsection{Uses}

Input Format Module (\nameref{input_format_module})

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
\begin{table}[H]
  \caption{Upload Interface Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
uploadFile & File (binary) & Boolean & FileError \\
captureImage & Image (binary) & Boolean & CaptureError \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

This module interacts with the device's file system for file uploads and the
device's camera for image capture. It also forwards the captured or uploaded
files to the Input Format Module for preprocessing.

\subsubsection{Assumptions}

\begin{itemize}
    \item The device has a functioning file system for uploads or a working camera for image capture.
    \item The file or image is in a supported format (e.g., JPEG, PNG).
    \item The Input Format Module is available and correctly configured.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent uploadFile():
\begin{itemize}
    \item transition: Validates and uploads the file, then forwards it to the Input Format Module.
    \item output: Returns true if the file upload is successful; false otherwise.
    \item exception: Throws a FileError if the file cannot be uploaded or is in an unsupported format.
\end{itemize}

\noindent captureImage():
\begin{itemize}
    \item transition: Captures an image using the device's camera and forwards it to the Input Format Module.
    \item output: Returns true if the image capture is successful; false otherwise.
    \item exception: Throws a CaptureError if the image capture fails.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item validateFile(): Ensures the uploaded file meets format and size requirements before processing.
    \item preprocessImage(): Applies basic pre-processing steps to captured images, such as resizing or compression.
\end{itemize}

\newpage
% end of upload interface module


% start of results display module
\section{MIS of Results Display Module}\label{results_display_module}

\subsection{Module}

Results Display Module

\subsection{Uses}

Input Format Module (\nameref{input_format_module})\\
Budget Calculation Module (\nameref{budget_calculation_module})\\
Categorization Module (\nameref{categorization_module})\\

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{table}[H]
    \caption{Input Format Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
displayResults & CategorizedData, BudgetPlan & Visualization (UI Component) & DisplayError \\
\hline
generateExportFile & FormatType (CSV, PDF) & File & ExportError \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{currentView}: Stores the current state of the results view, such as the displayed budget or expense category.
    \item \texttt{dataCache}: Temporarily holds the processed data for display purposes.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item Screen interface: Used to display the results in a user-friendly format.
    \item File system: Accessed for exporting reports in specified formats.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item Assumes the input data has been properly processed and categorized by upstream modules.
    \item Assumes the screen interface and file system are operational and accessible.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{displayResults}(CategorizedData, BudgetPlan):
\begin{itemize}
    \item \textbf{transition:} Updates the \texttt{currentView} to display the given data.
    \item \textbf{output:} Renders categorized expenses, financial suggestions, and budget plans in a user-friendly format.
    \item \textbf{exception:} Throws \texttt{DisplayError} if the UI components fail to render properly.
\end{itemize}

\noindent \texttt{generateExportFile}(FormatType):
\begin{itemize}
    \item \textbf{transition:} Creates an exportable file (CSV or PDF) from the current view data.
    \item \textbf{output:} Returns a file object for download or storage.
    \item \textbf{exception:} Throws \texttt{ExportError} if file generation fails due to unsupported format or data corruption.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{formatDataForExport(Data, FormatType)}: Converts the processed data into the specified format for export purposes.
    \item \texttt{updateView(ViewState)}: Updates the UI state to reflect the latest data or user interaction.
\end{itemize}

\newpage
% end of results display module


% start of input format module
\section{MIS of Input Format Module}\label{input_format_module}

\subsection{Module}

Input Format Module

\subsection{Uses}

Results Display Module (\nameref{results_display_module})\\
Budget Calculation Module (\nameref{budget_calculation_module})\\
Categorization Module (\nameref{categorization_module})\\

\subsection{Syntax}

\subsubsection{Exported Constants}

None

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{table}[H]
    \caption{Input Format Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
parseInputData & RawInputData & StructuredData & ParseError \\
\hline
validateInputFormat & RawInputData & Boolean & ValidationError \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{lastParsedData}: Stores the most recent successfully parsed input data.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item File system: For reading input data files or streams.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item Assumes input data adheres to a general predefined structure, such as receipts in text or image format.
    \item Assumes input errors (e.g., invalid formats) will be handled through exceptions.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{parseInputData}(RawInputData):
\begin{itemize}
    \item \textbf{transition:} Updates \texttt{lastParsedData} with the processed input.
    \item \textbf{output:} Converts raw input data into a structured format usable by other modules.
    \item \textbf{exception:} Throws \texttt{ParseError} if the input cannot be parsed due to formatting issues or invalid data.
\end{itemize}

\noindent \texttt{validateInputFormat}(RawInputData):
\begin{itemize}
    \item \textbf{transition:} None
    \item \textbf{output:} Returns \texttt{true} if the input format is valid, \texttt{false} otherwise.
    \item \textbf{exception:} Throws \texttt{ValidationError} for non-parsable or unsupported formats.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{extractRelevantFields(RawInputData)}: Isolates key fields from raw input for processing.
    \item \texttt{mapToStructuredFormat(Fields)}: Maps extracted fields to the final structured format.
\end{itemize}

\newpage
% end of input format module


% start of output generation module
\section{MIS of Output Generation Module}\label{output_generation_module}

\subsection{Module}

Output Generation Module

\subsection{Uses}

Budget Calculation Module (\nameref{budget_calculation_module})\\
Results Display Module (\nameref{results_display_module})\\

\subsection{Syntax}

\subsubsection{Exported Constants}

N/A

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{table}[H]
    \caption{Output Generation Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
generateReport & ProcessedData, FormatType & ReportFile & ReportGenerationError \\
\hline
displayOnScreen & ProcessedData & DisplayOutput & DisplayError \\
\hline
exportFile & ProcessedData, ExportType & ExportFile & ExportError \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
    \item \texttt{lastGeneratedReport}: Stores the last successfully generated report for reference or re-export.
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
    \item File system: For saving reports and exported files (e.g., CSV, PDF).
    \item User interface: For displaying outputs on screen.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
    \item Assumes input data (ProcessedData) is correctly formatted and validated by preceding modules.
    \item Assumes the requested output format (e.g., CSV, PDF) is supported by the module.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{generateReport}(ProcessedData, FormatType):
\begin{itemize}
    \item \textbf{transition:} Updates \texttt{lastGeneratedReport} with the newly created report.
    \item \textbf{output:} Produces a formatted report file in the specified format (e.g., PDF, CSV).
    \item \textbf{exception:} Throws \texttt{ReportGenerationError} if the report generation fails (e.g., due to unsupported format or missing data).
\end{itemize}

\noindent \texttt{displayOnScreen}(ProcessedData):
\begin{itemize}
    \item \textbf{transition:} None
    \item \textbf{output:} Renders the processed data into a user-friendly display format on the screen.
    \item \textbf{exception:} Throws \texttt{DisplayError} if the display rendering fails.
\end{itemize}

\noindent \texttt{exportFile}(ProcessedData, ExportType):
\begin{itemize}
    \item \textbf{transition:} Saves the processed data into an exportable file format (e.g., CSV, Excel).
    \item \textbf{output:} Returns a reference to the exported file.
    \item \textbf{exception:} Throws \texttt{ExportError} if the export operation fails.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
    \item \texttt{formatData(ProcessedData, FormatType)}: Converts the processed data into the requested format.
    \item \texttt{renderScreenOutput(ProcessedData)}: Prepares the processed data for screen display.
\end{itemize}

\newpage
% end of output generation module


% start of expense module
\section{MIS of Expense}\label{expense_module}

\subsection{Module}

Expense module

\subsection{Uses}
N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \textbf{name}: string
  \item \textbf{cost}: float
  \item \textbf{category}: string
  \item \textbf{transaction\_date}: datetime
  \item \textbf{user\_id}: Uuid
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{table}[H]
    \caption{Expense Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
expense & name: string &  &  \\
  & cost: float &  &  \\
  & category: string &  &  \\
  & transaction\_date: datetime &  &  \\
  & user\_id: Uuid &  &  \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}

\noindent expense(name: string, cost: float, category: string,
transaction\_date: datetime, user\_id: Uuid):
\begin{itemize}
\item transition: N/A
\item output: Expense
\item exception: InvalidInputError -- thrown if the input is not valid
\end{itemize}

\subsubsection{Local Functions}
N/A

\newpage
% end of expense module

% start of income module
\section{MIS of Income}\label{income_module}

\subsection{Module}

Income module

\subsection{Uses}
N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \textbf{name}: string
  \item \textbf{amount}: float
  \item \textbf{recurring}: bool
  \item \textbf{frequency}: Optional[string]
  \item \textbf{start}: datetime
  \item \textbf{user\_id}: Uuid
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{table}[H]
    \caption{Income Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
income & name: string &  &  \\
  & amount: float &  &  \\
  & recurring: bool &  &  \\
  & frequency: Optional[string] &  &  \\
  & start: datetime &  &  \\
  & user\_id: Uuid &  &  \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}

\noindent income(name: string, amount: float, recurring: bool, frequency:
Optional[string], start: datetime, user\_id: Uuid):
\begin{itemize}
\item transition: N/A
\item output: Income
\item exception: InvalidInputError -- thrown if the input is not valid
\end{itemize}

\subsubsection{Local Functions}
N/A

\newpage
% end of income module

% start of budget module
\section{MIS of Budget}\label{budget_module}

\subsection{Module}

Budget module

\subsection{Uses}
N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
  \item \textbf{category}: string
  \item \textbf{amount}: float
  \item \textbf{user\_id}: Uuid
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{table}[H]
    \caption{Budget Module Access Programs}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
budget & category: string &  & InvalidInputError \\
  & amount: float &  &  \\
  & user\_id: Uuid &  &  \\
\hline
\end{tabular}
\end{table}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}
N/A

\subsubsection{Access Routine Semantics}

\noindent budget(category: string, amount: float, user\_id: Uuid):
\begin{itemize}
\item transition: N/A
\item output: Budget
\item exception: InvalidInputError -- thrown if the input is not valid
\end{itemize}

\subsubsection{Local Functions}
N/A

\newpage
% end of budget module


% % start of MIS template
% \section{MIS of \wss{Module Name}}\label{Module}

% \subsection{Module}

% \wss{Short name for the module}

% \subsection{Uses}


% \subsection{Syntax}

% \subsubsection{Exported Constants}

% \subsubsection{Exported Access Programs}

% \begin{center}
% \begin{table}[H]
%   \caption{X Module Access Programs}
% \begin{tabular}{p{4cm} p{4cm} p{4cm} p{4cm}}
% \hline
% \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
% \hline
% \wss{accessProg} & - & - & - \\
% \hline
% \end{tabular}
% \end{table}
% \end{center}

% \subsection{Semantics}

% \subsubsection{State Variables}

% \wss{Not all modules will have state variables.  State variables give the module
%   a memory.}

% \subsubsection{Environment Variables}

% \wss{This section is not necessary for all modules.  Its purpose is to capture
%   when the module has external interaction with the environment, such as for a
%   device driver, screen interface, keyboard, file, etc.}

% \subsubsection{Assumptions}

% \wss{Try to minimize assumptions and anticipate programmer errors via
%   exceptions, but for practical purposes assumptions are sometimes appropriate.}

% \subsubsection{Access Routine Semantics}

% \noindent \wss{accessProg}():
% \begin{itemize}
% \item transition: \wss{if appropriate} 
% \item output: \wss{if appropriate} 
% \item exception: \wss{if appropriate} 
% \end{itemize}

% \wss{A module without environment variables or state variables is unlikely to
%   have a state transition.  In this case a state transition can only occur if
%   the module is changing the state of another module.}

% \wss{Modules rarely have both a transition and an output.  In most cases you
%   will have one or the other.}

% \subsubsection{Local Functions}

% \wss{As appropriate} \wss{These functions are for the purpose of specification.
%   They are not necessarily something that is going to be implemented
%   explicitly.  Even if they are implemented, they are not exported; they only
%   have local scope.}

% \newpage
% % end of MIS template



\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage


\newpage{}

\section*{Appendix --- Reflection}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 

  During the deliverable, the team was able to divide the work up well and the process went seamlessly for each member finishing up their corresponding section punctually. 
  As well, any questions or concerns that the team had were brought up and discussed in an orderly manner in order to resolve any confusion. 

  \item What pain points did you experience during this deliverable, and how
    did you resolve them?

    During the completion of the MG document, we were confused regarding the structure of the DAG diagram, and what the module hierarchy was supposed to look like. The issues surrounding the module
    hierarchy were resolved during our meeting with Lucas, and the remaining issues we had with the DAG diagram were discussed as a group. A major pain point was the structure of the DAG diagram
    and after a lengthy discussion, we reached out to Lucas with a couple of solutions to compare which meets the requirements of the section better.

  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?

  One of the main design decisions that we weren't sure about was what users want to see on their home page. After asking potential users, we found that a potential pain point (when it comes to 
  budgetting) for many users was that they are unaware of how much they've spent over a certain interval, and how much is left in their budget due to the accumulation of small expenses. 
  Furthermore, we asked users about potential features that they'd like to have included into the app and one of the most requested features were spending metrics. The combination of these feedback
  points led to us displaying users spending metrics and habits on the home page. 

  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?

  During the completion of the design doc, we expect that the MIS doc may undergo changes as we haven't fully built out all of the modules outlined in the MG/MIS document. We anticipate that there
  may be changed regarding the software archietecture.\\
  However, we may need to update our Hazard Analysis and SRS corresponding to what receipt types are expected after further testing.

  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)

  In order to make the project better, we were thinking of adding more functionality (i.e. a social aspect where you could split bills with others within the app) and adjusting the classification
  and parsing model to be able to identify any type of receipt. For example, currently, some receipts heavily abbrieviate their items on the receipt, making it difficult for the classification model
  to be able to identify the item and categorize it. With more resources, we could potentially integrate our system with common grocery store chains to train the model in order to identify those
  cryptic items on receipts.

  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)

  One of the main design decisions that we stayed away from was the use of too
  many user inputs. Our solution is to make a more efficient experience for
  users, and as a result we decided to stay away from designs that would require
  many user input fields. We also considered the design of using a dictionary
  for data types instead of an object, but we decided that an object would be
  cleaner and more efficient for our purposes. While a dictionary would have
  been easier to define, we decided to go with creating new classes because it
  would ensure that the data is structured in a way that would minimize errors
  (e.g., Item (\ref{item_module}) and Expense (\ref{expense_module})).

\end{enumerate}


\end{document}